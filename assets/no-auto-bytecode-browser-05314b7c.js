class g extends Error{constructor(a){super(a),this.name="AddChainError"}}class _ extends Error{constructor(){super(),this.name="AlreadyDestroyedError"}}class S extends Error{constructor(){super(),this.name="JsonRpcDisabledError"}}class v extends Error{constructor(a){super(a)}}class A extends Error{constructor(){super("JSON-RPC requests queue is full")}}function y(c,a,d){return R(c,a,d),new TextDecoder().decode(c.slice(a,a+d))}function P(c,a){return R(c,a,1),c[a]}function x(c,a){return R(c,a,2),c[a]<<8|c[a+1]}function k(c,a){return R(c,a,4),(c[a]|c[a+1]<<8|c[a+2]<<16)+c[a+3]*16777216}function j(c,a,d){R(c,a,1),c[a]=d&255}function U(c,a,d){R(c,a,4),c[a+3]=d>>>24&255,c[a+2]=d>>>16&255,c[a+1]=d>>>8&255,c[a]=d&255}function R(c,a,d){if(!Number.isInteger(a)||a<0)throw new RangeError;if(a+d>c.length)throw new RangeError}var E=globalThis&&globalThis.__awaiter||function(c,a,d,r){function h(n){return n instanceof d?n:new d(function(u){u(n)})}return new(d||(d=Promise))(function(n,u){function t(s){try{o(r.next(s))}catch(i){u(i)}}function e(s){try{o(r.throw(s))}catch(i){u(i)}}function o(s){s.done?n(s.value):h(s.value).then(t,e)}o((r=r.apply(c,a||[])).next())})};function O(c,a,d){return E(this,void 0,void 0,function*(){const r={instance:null,currentTask:null,bufferIndices:new Array,advanceExecutionPromise:null,onShutdownExecutorOrWasmPanic:()=>{}},h={panic:(t,e)=>{const o=r.instance;r.instance=null,t>>>=0,e>>>=0;const s=y(new Uint8Array(o.exports.memory.buffer),t,e);throw d({ty:"wasm-panic",message:s,currentTask:r.currentTask}),r.onShutdownExecutorOrWasmPanic(),r.onShutdownExecutorOrWasmPanic=()=>{},new Error},random_get:(t,e)=>{const o=r.instance;t>>>=0,e>>>=0;const s=new Uint8Array(o.exports.memory.buffer).subarray(t,t+e);for(let i=0;i<e;i+=65536)c.getRandomValues(s.subarray(i,i+65536))},unix_timestamp_us:()=>{const t=Math.floor(Date.now());if(t<0)throw new Error("UNIX timestamp inferior to 0");return BigInt(t)*BigInt(1e3)},monotonic_clock_us:()=>{const t=c.performanceNow(),e=Math.floor(t);return BigInt(e)*BigInt(1e3)+BigInt(Math.floor((t-e)*1e3))},buffer_size:t=>r.bufferIndices[t].byteLength,buffer_copy:(t,e)=>{const o=r.instance;e=e>>>0;const s=r.bufferIndices[t];new Uint8Array(o.exports.memory.buffer).set(s,e)},advance_execution_ready:()=>{r.advanceExecutionPromise&&r.advanceExecutionPromise(),r.advanceExecutionPromise=null},json_rpc_responses_non_empty:t=>{d({ty:"json-rpc-responses-non-empty",chainId:t})},log:(t,e,o,s,i)=>{const f=r.instance;e>>>=0,o>>>=0,s>>>=0,i>>>=0;const p=new Uint8Array(f.exports.memory.buffer);let l=y(p,e,o),m=y(p,s,i);d({ty:"log",level:t,message:m,target:l})},start_timer:t=>{const e=r.instance;t>2147483647&&(t=2147483647),t<1&&typeof setImmediate=="function"?setImmediate(()=>{if(r.instance)try{e.exports.timer_finished()}catch{}}):setTimeout(()=>{if(r.instance)try{e.exports.timer_finished()}catch{}},t)},connection_type_supported:t=>{switch(t){case 0:case 1:case 2:return c.forbidTcp?0:1;case 4:case 5:case 6:return c.forbidNonLocalWs?0:1;case 7:return c.forbidWs?0:1;case 14:return c.forbidWss?0:1;case 16:case 17:return c.forbidWebRtc?0:1;default:throw new Error("Invalid connection type passed to `connection_type_supported`")}},connection_new:(t,e,o)=>{const s=r.instance,i=new Uint8Array(s.exports.memory.buffer);e>>>=0,o>>>=0;let f;switch(P(i,e)){case 0:case 1:case 2:{const p=x(i,e+1),l=y(i,e+3,o-3);f={ty:"tcp",port:p,hostname:l};break}case 4:case 6:{const p=x(i,e+1);f={ty:"websocket",url:"ws://"+y(i,e+3,o-3)+":"+p};break}case 5:{const p=x(i,e+1);f={ty:"websocket",url:"ws://["+y(i,e+3,o-3)+"]:"+p};break}case 14:{const p=x(i,e+1);f={ty:"websocket",url:"wss://"+y(i,e+3,o-3)+":"+p};break}case 16:{const p=x(i,e+1),l=i.slice(e+3,e+35),m=y(i,e+35,o-35);f={ty:"webrtc",ipVersion:"4",remoteTlsCertificateSha256:l,targetIp:m,targetPort:p};break}case 17:{const p=x(i,e+1),l=i.slice(e+3,e+35),m=y(i,e+35,o-35);f={ty:"webrtc",ipVersion:"6",remoteTlsCertificateSha256:l,targetIp:m,targetPort:p};break}default:throw new Error("Invalid encoded address passed to `connection_new`")}d({ty:"new-connection",connectionId:t,address:f})},reset_connection:t=>{d({ty:"connection-reset",connectionId:t})},connection_stream_open:t=>{d({ty:"connection-stream-open",connectionId:t})},connection_stream_reset:(t,e)=>{d({ty:"connection-stream-reset",connectionId:t,streamId:e})},stream_send:(t,e,o,s)=>{const i=r.instance;o>>>=0,s>>>=0;const f=new Uint8Array(i.exports.memory.buffer).slice(o,o+s);d({ty:"stream-send",connectionId:t,streamId:e,data:f})},stream_send_close:(t,e)=>{d({ty:"stream-send-close",connectionId:t,streamId:e})},current_task_entered:(t,e)=>{t>>>=0,e>>>=0;const o=y(new Uint8Array(r.instance.exports.memory.buffer),t,e);r.currentTask=o},current_task_exit:()=>{r.currentTask=null}},n=yield WebAssembly.instantiate(a,{smoldot:h});r.instance=n,r.instance.exports.init(c.maxLogLevel);const u=new Promise(t=>r.onShutdownExecutorOrWasmPanic=()=>t("stop"));return E(this,void 0,void 0,function*(){const t=c.cpuRateLimit;let e=0,o=c.performanceNow();for(;;){const s=new Promise(m=>r.advanceExecutionPromise=()=>m("ready"));if(!r.instance)break;r.instance.exports.advance_execution();const i=c.performanceNow(),f=i-o;o=i;const p=f*(1/t-1);if(e+=p,e>5){e>2147483646&&(e=2147483646);const m=new Promise(w=>setTimeout(()=>w("timeout"),e));if((yield Promise.race([m,u]))==="stop")break}if((yield Promise.race([s,u]))==="stop")break;const l=c.performanceNow();e-=l-o,e<-1e4&&(e=-1e4),o=l}r.instance&&d({ty:"executor-shutdown"})}),{request:(t,e)=>r.instance?(r.bufferIndices[0]=new TextEncoder().encode(t),r.instance.exports.json_rpc_send(0,e)>>>0):1,peekJsonRpcResponse:t=>{if(!r.instance)return null;const e=new Uint8Array(r.instance.exports.memory.buffer),o=r.instance.exports.json_rpc_responses_peek(t)>>>0,s=k(e,o)>>>0,i=k(e,o+4)>>>0;if(i!==0){const f=y(e,s,i);return r.instance.exports.json_rpc_responses_pop(t),f}else return null},addChain:(t,e,o,s,i,f)=>{if(!r.instance){d({ty:"add-chain-result",success:!1,error:"Smoldot has crashed"});return}console.assert(s||i!=0,"invalid jsonRpcMaxPendingRequests value passed to local-instance::addChain"),r.bufferIndices[0]=new TextEncoder().encode(t),r.bufferIndices[1]=new TextEncoder().encode(e);const p=new Uint8Array(o.length*4);for(let m=0;m<o.length;++m)U(p,m*4,o[m]);r.bufferIndices[2]=p;const l=r.instance.exports.add_chain(0,1,s?0:i,f,2);if(delete r.bufferIndices[0],delete r.bufferIndices[1],delete r.bufferIndices[2],r.instance.exports.chain_is_ok(l)!=0)d({ty:"add-chain-result",success:!0,chainId:l});else{const m=r.instance.exports.chain_error_len(l)>>>0,w=r.instance.exports.chain_error_ptr(l)>>>0,b=y(new Uint8Array(r.instance.exports.memory.buffer),w,m);r.instance.exports.remove_chain(l),d({ty:"add-chain-result",success:!1,error:b})}},removeChain:t=>{r.instance&&r.instance.exports.remove_chain(t)},shutdownExecutor:()=>{if(!r.instance)return;const t=r.onShutdownExecutorOrWasmPanic;r.onShutdownExecutorOrWasmPanic=()=>{},t()},connectionMultiStreamSetHandshakeInfo:(t,e)=>{if(!r.instance)return;const o=new Uint8Array(1+e.localTlsCertificateSha256.length+e.remoteTlsCertificateSha256.length);j(o,0,0),o.set(e.localTlsCertificateSha256,1),o.set(e.remoteTlsCertificateSha256,1+e.localTlsCertificateSha256.length),r.bufferIndices[0]=o,r.instance.exports.connection_multi_stream_set_handshake_info(t,0),delete r.bufferIndices[0]},connectionReset:(t,e)=>{r.instance&&(r.bufferIndices[0]=new TextEncoder().encode(e),r.instance.exports.connection_reset(t,0),delete r.bufferIndices[0])},streamWritableBytes:(t,e,o)=>{r.instance&&r.instance.exports.stream_writable_bytes(t,o||0,e)},streamMessage:(t,e,o)=>{r.instance&&(r.bufferIndices[0]=e,r.instance.exports.stream_message(t,o||0,0),delete r.bufferIndices[0])},streamOpened:(t,e,o)=>{r.instance&&r.instance.exports.connection_stream_opened(t,e,o==="outbound"?1:0)},streamReset:(t,e)=>{r.instance&&r.instance.exports.stream_reset(t,e)}}})}var T=globalThis&&globalThis.__awaiter||function(c,a,d,r){function h(n){return n instanceof d?n:new d(function(u){u(n)})}return new(d||(d=Promise))(function(n,u){function t(s){try{o(r.next(s))}catch(i){u(i)}}function e(s){try{o(r.throw(s))}catch(i){u(i)}}function o(s){s.done?n(s.value):h(s.value).then(t,e)}o((r=r.apply(c,a||[])).next())})};function B(c){return T(this,void 0,void 0,function*(){const{port1:a,port2:d}=new MessageChannel,r=c.portToServer,h={wasmModule:yield c.wasmModule,serverToClient:d,maxLogLevel:c.maxLogLevel,cpuRateLimit:c.cpuRateLimit,forbidWs:c.forbidWs,forbidWss:c.forbidWss,forbidNonLocalWs:c.forbidNonLocalWs,forbidTcp:c.forbidTcp,forbidWebRtc:c.forbidWebRtc};r.postMessage(h,[d]);const n={jsonRpcResponses:new Map,connections:new Map};return a.onmessage=u=>{const t=u.data;switch(t.ty){case"wasm-panic":case"executor-shutdown":{a.close(),r.close();break}case"add-chain-result":{if(t.success){n.jsonRpcResponses.set(t.chainId,new Array);const e={ty:"accept-more-json-rpc-answers",chainId:t.chainId};for(let o=0;o<10;++o)a.postMessage(e)}break}case"new-connection":{n.connections.set(t.connectionId,new Set);break}case"connection-reset":{if(!n.connections.has(t.connectionId))return;n.connections.delete(t.connectionId);break}case"connection-stream-open":{if(!n.connections.has(t.connectionId))return;break}case"connection-stream-reset":{if(!n.connections.has(t.connectionId)||!n.connections.get(t.connectionId).has(t.streamId))return;break}case"stream-send":{if(!n.connections.has(t.connectionId)||t.streamId&&!n.connections.get(t.connectionId).has(t.streamId))return;break}case"stream-send-close":{if(!n.connections.has(t.connectionId)||t.streamId&&!n.connections.get(t.connectionId).has(t.streamId))return;break}case"json-rpc-response":{const e=n.jsonRpcResponses.get(t.chainId);e&&e.push(t.response),c.eventCallback({ty:"json-rpc-responses-non-empty",chainId:t.chainId});return}}c.eventCallback(t)},{addChain(u,t,e,o,s,i){return T(this,void 0,void 0,function*(){const f={ty:"add-chain",chainSpec:u,databaseContent:t,potentialRelayChains:e,disableJsonRpc:o,jsonRpcMaxPendingRequests:s,jsonRpcMaxSubscriptions:i};a.postMessage(f)})},removeChain(u){n.jsonRpcResponses.delete(u);const t={ty:"remove-chain",chainId:u};a.postMessage(t)},request(u,t){const e={ty:"request",chainId:t,request:u};return a.postMessage(e),0},peekJsonRpcResponse(u){const t=n.jsonRpcResponses.get(u).shift();if(!t)return null;const e={ty:"accept-more-json-rpc-answers",chainId:u};return a.postMessage(e),t},shutdownExecutor(){const u={ty:"shutdown"};a.postMessage(u)},connectionReset(u,t){n.connections.delete(u);const e={ty:"connection-reset",connectionId:u,message:t};a.postMessage(e)},connectionMultiStreamSetHandshakeInfo(u,t){const e={ty:"connection-multistream-set-info",connectionId:u,info:t};a.postMessage(e)},streamMessage(u,t,e){const o={ty:"stream-message",connectionId:u,message:t,streamId:e};a.postMessage(o)},streamOpened(u,t,e){n.connections.get(u).add(t);const o={ty:"stream-opened",connectionId:u,streamId:t,direction:e};a.postMessage(o)},streamWritableBytes(u,t,e){const o={ty:"stream-writable-bytes",connectionId:u,numExtra:t,streamId:e};a.postMessage(o)},streamReset(u,t){n.connections.get(u).delete(t);const e={ty:"stream-reset",connectionId:u,streamId:t};a.postMessage(e)}}})}var I=globalThis&&globalThis.__awaiter||function(c,a,d,r){function h(n){return n instanceof d?n:new d(function(u){u(n)})}return new(d||(d=Promise))(function(n,u){function t(s){try{o(r.next(s))}catch(i){u(i)}}function e(s){try{o(r.throw(s))}catch(i){u(i)}}function o(s){s.done?n(s.value):h(s.value).then(t,e)}o((r=r.apply(c,a||[])).next())})};function L(c,a,d){const r=c.logCallback||((e,o,s)=>{e<=1?console.error("[%s] %s",o,s):e==2?console.warn("[%s] %s",o,s):e==3?console.info("[%s] %s",o,s):e==4?console.debug("[%s] %s",o,s):console.trace("[%s] %s",o,s)});a instanceof Promise||(a=Promise.resolve(a));let h=c.cpuRateLimit||1;isNaN(h)&&(h=1),h>1&&(h=1),h<0&&(h=0);const n={instance:{status:"not-created"},chainIds:new WeakMap,connections:new Map,addChainResults:[],onExecutorShutdownOrWasmPanic:()=>{},chains:new Map},u=e=>{switch(e.ty){case"wasm-panic":{console.error("Smoldot has panicked"+(e.currentTask?" while executing task `"+e.currentTask+"`":"")+`. This is a bug in smoldot. Please open an issue at https://github.com/smol-dot/smoldot/issues with the following message:
`+e.message),n.instance={status:"destroyed",error:new v(e.message)},n.connections.forEach(s=>s.reset()),n.connections.clear();for(const s of n.addChainResults)s({success:!1,error:"Smoldot has crashed"});n.addChainResults=[];for(const s of Array.from(n.chains.values())){for(const i of s.jsonRpcResponsesPromises)i();s.jsonRpcResponsesPromises=[]}n.chains.clear();const o=n.onExecutorShutdownOrWasmPanic;n.onExecutorShutdownOrWasmPanic=()=>{},o();break}case"executor-shutdown":{const o=n.onExecutorShutdownOrWasmPanic;n.onExecutorShutdownOrWasmPanic=()=>{},o();break}case"log":{r(e.level,e.target,e.message);break}case"add-chain-result":{n.addChainResults.shift()(e);break}case"json-rpc-responses-non-empty":{const o=n.chains.get(e.chainId).jsonRpcResponsesPromises;for(;o.length!==0;)o.shift()();break}case"new-connection":{const o=e.connectionId;n.connections.set(o,d.connect({address:e.address,onConnectionReset(s){if(n.instance.status!=="ready")throw new Error;n.connections.delete(o),n.instance.instance.connectionReset(o,s)},onMessage(s,i){if(n.instance.status!=="ready")throw new Error;n.instance.instance.streamMessage(o,s,i)},onStreamOpened(s,i){if(n.instance.status!=="ready")throw new Error;n.instance.instance.streamOpened(o,s,i)},onMultistreamHandshakeInfo(s){if(n.instance.status!=="ready")throw new Error;n.instance.instance.connectionMultiStreamSetHandshakeInfo(o,s)},onWritableBytes(s,i){if(n.instance.status!=="ready")throw new Error;n.instance.instance.streamWritableBytes(o,s,i)},onStreamReset(s){if(n.instance.status!=="ready")throw new Error;n.instance.instance.streamReset(o,s)}}));break}case"connection-reset":{n.connections.get(e.connectionId).reset(),n.connections.delete(e.connectionId);break}case"connection-stream-open":{n.connections.get(e.connectionId).openOutSubstream();break}case"connection-stream-reset":{n.connections.get(e.connectionId).reset(e.streamId);break}case"stream-send":{n.connections.get(e.connectionId).send(e.data,e.streamId);break}case"stream-send-close":{n.connections.get(e.connectionId).closeSend(e.streamId);break}}},t=c.portToWorker;return t?n.instance={status:"not-ready",whenReady:B({wasmModule:a.then(e=>e.wasm),forbidTcp:c.forbidTcp||!1,forbidWs:c.forbidWs||!1,forbidNonLocalWs:c.forbidNonLocalWs||!1,forbidWss:c.forbidWss||!1,forbidWebRtc:c.forbidWebRtc||!1,maxLogLevel:c.maxLogLevel||3,cpuRateLimit:h,portToServer:t,eventCallback:u}).then(e=>{n.instance.status!=="destroyed"&&(n.instance={status:"ready",instance:e})})}:n.instance={status:"not-ready",whenReady:a.then(e=>O({forbidTcp:c.forbidTcp||!1,forbidWs:c.forbidWs||!1,forbidNonLocalWs:c.forbidNonLocalWs||!1,forbidWss:c.forbidWss||!1,forbidWebRtc:c.forbidWebRtc||!1,maxLogLevel:c.maxLogLevel||3,cpuRateLimit:h,envVars:[],performanceNow:d.performanceNow,getRandomValues:d.getRandomValues},e.wasm,u)).then(e=>{n.instance.status!=="destroyed"&&(n.instance={status:"ready",instance:e})})},{addChain:e=>I(this,void 0,void 0,function*(){if(n.instance.status==="not-ready"&&(yield n.instance.whenReady),n.instance.status==="destroyed")throw n.instance.error;if(n.instance.status==="not-created"||n.instance.status==="not-ready")throw new Error;if(typeof e.chainSpec!="string")throw new Error("Chain specification must be a string");let o=[];if(e.potentialRelayChains)for(const w of e.potentialRelayChains){const b=n.chainIds.get(w);b!==void 0&&o.push(b)}let s=e.jsonRpcMaxPendingRequests===void 0?1/0:e.jsonRpcMaxPendingRequests;if(s=Math.floor(s),s<=0||isNaN(s))throw new g("Invalid value for `jsonRpcMaxPendingRequests`");s>4294967295&&(s=4294967295);let i=e.jsonRpcMaxSubscriptions===void 0?1/0:e.jsonRpcMaxSubscriptions;if(i=Math.floor(i),i<0||isNaN(i))throw new g("Invalid value for `jsonRpcMaxSubscriptions`");if(i>4294967295&&(i=4294967295),e.databaseContent!==void 0&&typeof e.databaseContent!="string")throw new g("`databaseContent` is not a string");const f=new Promise(w=>n.addChainResults.push(w));n.instance.instance.addChain(e.chainSpec,e.databaseContent||"",o,!!e.disableJsonRpc,s,i);const p=yield f;if(!p.success)throw new g(p.error);const l=p.chainId;n.chains.set(l,{jsonRpcResponsesPromises:new Array});const m={sendJsonRpc:w=>{if(n.instance.status==="destroyed")throw n.instance.error;if(n.instance.status!=="ready")throw new Error;if(!n.chains.has(l))throw new _;if(e.disableJsonRpc)throw new S;const b=n.instance.instance.request(w,l);switch(b){case 0:break;case 1:throw new A;default:throw new Error("Internal error: unknown json_rpc_send error code: "+b)}},nextJsonRpcResponse:()=>I(this,void 0,void 0,function*(){for(;;){if(!n.chains.has(l))throw new _;if(e.disableJsonRpc)return Promise.reject(new S);if(n.instance.status==="destroyed")throw n.instance.error;if(n.instance.status!=="ready")throw new Error;const w=n.instance.instance.peekJsonRpcResponse(l);if(w)return w;yield new Promise(b=>{n.chains.get(l).jsonRpcResponsesPromises.push(b)})}}),remove:()=>{if(n.instance.status==="destroyed")throw n.instance.error;if(n.instance.status!=="ready")throw new Error;if(!n.chains.has(l))throw new _;console.assert(n.chainIds.has(m)),n.chainIds.delete(m);for(const w of n.chains.get(l).jsonRpcResponsesPromises)w();n.chains.delete(l),n.instance.instance.removeChain(l)}};return n.chainIds.set(m,l),m}),terminate:()=>I(this,void 0,void 0,function*(){if(n.instance.status==="not-ready"&&(yield n.instance.whenReady),n.instance.status==="destroyed")throw n.instance.error;if(n.instance.status!=="ready")throw new Error;n.instance.instance.shutdownExecutor(),yield new Promise(e=>n.onExecutorShutdownOrWasmPanic=e),n.instance.status==="ready"&&(n.instance={status:"destroyed",error:new _}),n.connections.forEach(e=>e.reset()),n.connections.clear();for(const e of n.addChainResults)e({success:!1,error:"Client.terminate() has been called"});n.addChainResults=[];for(const e of Array.from(n.chains.values())){for(const o of e.jsonRpcResponsesPromises)o();e.jsonRpcResponsesPromises=[]}n.chains.clear()})}}var W=globalThis&&globalThis.__awaiter||function(c,a,d,r){function h(n){return n instanceof d?n:new d(function(u){u(n)})}return new(d||(d=Promise))(function(n,u){function t(s){try{o(r.next(s))}catch(i){u(i)}}function e(s){try{o(r.throw(s))}catch(i){u(i)}}function o(s){s.done?n(s.value):h(s.value).then(t,e)}o((r=r.apply(c,a||[])).next())})};function q(c){return c.forbidTcp=!0,L(c,c.bytecode,{performanceNow:()=>performance.now(),getRandomValues:a=>{const d=globalThis.crypto;if(!d)throw new Error("randomness not available");if(a.buffer instanceof ArrayBuffer)d.getRandomValues(a);else{const r=new Uint8Array(a.length);d.getRandomValues(r),a.set(r)}},connect:a=>N(a)})}function N(c){if(c.address.ty==="websocket"){let a;try{a=new WebSocket(c.address.url)}catch(h){a=h instanceof Error?h.toString():"Exception thrown by new WebSocket"}const d={quenedUnreportedBytes:0,nextTimeout:10},r=()=>{if(!(a instanceof WebSocket)||a.readyState!=1)return;const h=a.bufferedAmount;let n=d.quenedUnreportedBytes-h;n<0&&(n=0),d.quenedUnreportedBytes-=n,d.quenedUnreportedBytes!=0&&(setTimeout(r,d.nextTimeout),d.nextTimeout*=2,d.nextTimeout>500&&(d.nextTimeout=500)),n!=0&&c.onWritableBytes(n)};return a instanceof WebSocket?(a.binaryType="arraybuffer",a.onopen=()=>{c.onWritableBytes(1024*1024)},a.onclose=h=>{const n="Error code "+h.code+(h.reason?": "+h.reason:"");c.onConnectionReset(n)},a.onmessage=h=>{c.onMessage(new Uint8Array(h.data))}):setTimeout(()=>{a&&!(a instanceof WebSocket)&&(c.onConnectionReset(a),a=null)},1),{reset:()=>{a instanceof WebSocket&&(a.onopen=null,a.onclose=null,a.onmessage=null,a.onerror=null,a.readyState==WebSocket.OPEN&&a.close()),a=null},send:h=>{a.send(h),d.quenedUnreportedBytes==0&&(d.nextTimeout=10,setTimeout(r,10)),d.quenedUnreportedBytes+=h.length},closeSend:()=>{throw new Error("Wrong connection type")},openOutSubstream:()=>{throw new Error("Wrong connection type")}}}else if(c.address.ty==="webrtc"){const{targetPort:a,ipVersion:d,targetIp:r,remoteTlsCertificateSha256:h}=c.address;let n;const u=new Map;let t;const e=()=>{if(!n){console.assert(u.size===0,"substreams exist while pc is undef"),n=null;return}n.onconnectionstatechange=null,n.onnegotiationneeded=null,n.ondatachannel=null;for(const s of Array.from(u.values()))s.channel.onopen=null,s.channel.onerror=null,s.channel.onclose=null,s.channel.onbufferedamountlow=null,s.channel.onmessage=null;u.clear(),n.close()},o=(s,i)=>{const f=s.id;s.binaryType="arraybuffer";let p={value:!1};s.onopen=()=>{console.assert(!p.value,"substream opened twice"),p.value=!0,c.onStreamOpened(f,i),c.onWritableBytes(65536,f)},s.onerror=s.onclose=l=>{p.value?c.onStreamReset(f):(e(),c.onConnectionReset("data channel failed to open"))},s.onbufferedamountlow=()=>{const l=u.get(f),m=l.bufferedBytes;l.bufferedBytes=0,c.onWritableBytes(m,f)},s.onmessage=l=>{c.onMessage(new Uint8Array(l.data),f)},u.set(f,{channel:s,bufferedBytes:0})};return RTCPeerConnection.generateCertificate({name:"ECDSA",namedCurve:"P-256",hash:"SHA-256"}).then(s=>W(this,void 0,void 0,function*(){if(n===null)return;n=new RTCPeerConnection({certificates:[s]});let i;if(s.getFingerprints){for(const{algorithm:f,value:p}of s.getFingerprints())if(f==="sha-256"){i=p;break}}else{const p=(yield n.createOffer()).sdp.match(/a(\s*)=(\s*)fingerprint:(\s*)(sha|SHA)-256(\s*)(([a-fA-F0-9]{2}(:)*){32})/);p&&(i=p[6])}if(i===void 0){c.onConnectionReset("Failed to obtain the browser certificate fingerprint");return}t=new Uint8Array(32),t.set(i.split(":").map(f=>parseInt(f,16)),0),n.onconnectionstatechange=f=>{(n.connectionState=="closed"||n.connectionState=="disconnected"||n.connectionState=="failed")&&(e(),c.onConnectionReset("WebRTC state transitioned to "+n.connectionState))},n.onnegotiationneeded=f=>W(this,void 0,void 0,function*(){var p;let l=(yield n.createOffer()).sdp;l.match(/^m=application(\s+)(\d+)(\s+)UDP\/DTLS\/SCTP(\s+)webrtc-datachannel$/m)===null&&console.error("Local offer doesn't contain UDP data channel. WebRTC connections will likely fail. Please report this issue.");const m=(p=l.match(/^a=ice-pwd:(.+)$/m))===null||p===void 0?void 0:p.at(1);m===void 0&&console.error("Failed to set ufrag to pwd. WebRTC connections will likely fail. Please report this issue.");const w="libp2p+webrtc+v1/"+m;l=l.replace(/^a=ice-ufrag.*$/m,"a=ice-ufrag:"+w),l=l.replace(/^a=ice-pwd.*$/m,"a=ice-pwd:"+w),yield n.setLocalDescription({type:"offer",sdp:l});const b=Array.from(h).map(M=>("0"+M.toString(16)).slice(-2).toUpperCase()).join(":"),C=`v=0
o=- 0 0 IN IP`+d+" "+r+`
s=-
t=0 0
a=ice-lite
m=application `+String(a)+` UDP/DTLS/SCTP webrtc-datachannel
c=IN IP`+d+" "+r+`
a=mid:0
a=ice-options:ice2
a=ice-ufrag:`+w+`
a=ice-pwd:`+w+`
a=fingerprint:sha-256 `+b+`
a=setup:passive
a=sctp-port:5000
a=max-message-size:16384
a=candidate:1 1 UDP 1 `+r+" "+String(a)+` typ host
`;yield n.setRemoteDescription({type:"answer",sdp:C})}),n.ondatachannel=({channel:f})=>{o(f,"inbound")},c.onMultistreamHandshakeInfo({handshake:"webrtc",localTlsCertificateSha256:t,remoteTlsCertificateSha256:h})})),{reset:s=>{if(s===void 0)e();else{const i=u.get(s);i.channel.onopen=null,i.channel.onerror=null,i.channel.onclose=null,i.channel.onbufferedamountlow=null,i.channel.onmessage=null,i.channel.close(),u.delete(s)}},send:(s,i)=>{const f=u.get(i);f.channel.send(s),f.bufferedBytes+=s.length},closeSend:()=>{throw new Error("Wrong connection type")},openOutSubstream:()=>{o(n.createDataChannel(""),"outbound")}}}else throw new Error}export{g as AddChainError,_ as AlreadyDestroyedError,v as CrashError,S as JsonRpcDisabledError,A as QueueFullError,q as startWithBytecode};
